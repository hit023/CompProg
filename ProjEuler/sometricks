*n = n * 2 :: n = n << 1
*n = n /2  :: n = n >> 1
*checking if n is power of 2 (1,2,4,8â€¦) ::checking !(n & (n-1))
*if x is max power of 2 dividing n, then x = (n & -n)
*Total number of bits which are set in n = __builtin_popcount(n)
*setting xth bit of n  :: n |= (1<<x)
*checking if xth bit of n is set :: checking if  n&(1<<x) is non zero
*use acos(-1) for pi if precision is not an issue.
*to use a floating-point number with a required number of decimal places, use- http://stackoverflow.com/questions/3383817/limit-floating-point-precision
*apply seive whenever possible. See cube-free numbers.(Cubes, higher powers- works for all!) http://www.spoj.com/problems/CUBEFR/
*to add one-> -(~x)
*to check if the sum of a subarray of a bigger array sums up to a given quantity, always use recursion for a quick sol.See the following
https://www.codechef.com/problems/MARCHA1
*use scanf and printf if faster i/o than cin and cout is required.
*use getchar_unlocked only when badly needed.
*using cin.tie(0) also helps sometimes because one can now break teh tie between cina nd cout and this results in haphazard output because they are not synchronised anymore. Cout won't flush out before a cin is used anymore. So no continuity!
